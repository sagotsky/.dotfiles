###functions

#ls which does ls -lh on result of which.  useful if /usr/bin/$BINARY is a symlink 
function lw() { 
	 if [ $# -gt 1 ] ; then 
	    for bin in $@ ; do lw $bin ; done 
     elif [ $# -gt 0  ] ; then
       bin=$(which $1)
       [[ "$?" == "0" && -e "$bin" ]] && ls -lh "$bin"
       [[ -L "$bin" ]] && lw $(readlink $bin) || true
	 else 
	    echo "lw (ls which) requires more than 0 arguments"
	 fi  
}

#make a dir, cd into it
function mkcd() {
	 mkdir -p "$@";
	 pushd "$@" > /dev/null;
	 echo $PWD;
}

# extract archives.  should handle multiple files.
function x() {
	 case $@ in 
	     *.tar.bz2)		tar -xvjf "$@"	;;	
	     *.tar.gz)		tar -xvzf "$@"	;;
       *.tar.lzma)    tar -xvf "$@" ;;
	     *.bz2)		bunzip2 "$@"	;;
	     *.rar)		unrar x "$@"	;;
	     *.gz)		gunzip "$@"	;;
	     *.tar) 		tar xf "$@"	;;
	     *.tbz2)		tar -xvjf "$@"	;;
	     *.tgz)		tar -xvzf "$@"	;;
	     *.zip)		unzip "$@"  	;;
	     *.xpi)		unzip "$@"  	;;
	     *.Z)		uncompress "$@"	;;
	     *.7z)		7z x "$@"	;;
	     *.ace)		unace e "$@"	;;
	     *.arj)		arj -y e "$@"	;;
	     *)			echo "'$@' cannot be extracted via x()"	;;
	 esac
}

# packs $2-$n into $1 depending on $1's extension.  add more file types as needed
function pack() {
	 if [ $# -lt 2 ] ; then
	    echo -e "\npack() usage:"
	    echo -e "\tpack archive_file_name file1 file2 ... fileN"
	    echo -e "\tcreates archive of files 1-N\n"
	 else 
	   DEST=$1
	   shift

	   case $DEST in 
		*.tar.bz2)		tar -cvjf $DEST "$@" ;;  
		*.tar.gz)		tar -cvzf $DEST "$@" ;;  
		*.tgz)  		tar -cvzf $DEST "$@" ;;  
		*.zip)			zip -r $DEST "$@" ;;
		*.xpi)			zip -r $DEST "$@" ;;
        *.7z)           7z a $DEST "$@" ;;
		*)				echo "Unknown file type - $DEST" ;;
	   esac
	 fi
}

# changes cd to pushd.  as a function so that cd with no args still brings you home.  see pd as popd
function cd() {
    if [ $# -eq 0 ] ; then
	pushd $HOME
    else
	pushd "$@" > /dev/null
    fi
}

function calc() {
	awk "BEGIN{ print $* }" ;
}

# returns age of file in seconds
function age() {
	CURRENT=$( date +%s )
	FILEAGE=$( stat -t $1 -c %Z )
	calc $CURRENT - $FILEAGE
}

# many or multi grep.  syntactic sugar for grep -l | xargs grep
function mgrep() {
    EXEC="ls "
    for term in "$@" ; do
        EXEC="$EXEC | xargs grep -l -i '$term' "
    done
    #echo $EXEC 1>&2
    eval $EXEC
}

function d6() {
  echo "⚀\n⚁\n⚂\n⚃\n⚄\n⚅" | shuf -n 1
}

function roll() {
    if [ $# -lt 1 ]  ; then
        echo -e "\nUsage: roll [n] d\n\nRoll n dice of size d.  If left out, n is assumed to be one.\n"
    else
        TYPE=$1
        if [ $# -eq 2 ] ; then
            TYPE=$2
            NUM=$1
        else
            NUM=1
        fi

        SUM=0
        for i in `seq $NUM` ; do 
            # seq 1 $TYPE | shuf -n 1
            ROLL=$(( $RANDOM%$TYPE + 1 ))
            echo $ROLL
            SUM=$(( $SUM + $ROLL ))
        done
        
        echo 
        echo "=> $SUM"
    fi

}
function nosleep() {
    # if this still doesn't work, fork $@ and run deactivate or reset periodically
    xset -dpms
    xset s off
    $@
    xset +dpms
    xset s on
}

function dec2base() {
    if [ $# -ne 2 ] ; then
        echo -e "\nUsage: dec2base number base.\n"
    else 
        echo "$1 $2 o p " | dc
    fi
}

# prints n paragraphs of lorem ipsum text.  n defaults to 5 thanks to lipsum.com being cool.
function loremipsum() {
     curl -s "http://loripsum.net/api/$1/short/headers/plaintext"
}

# repeats a command n times.  no loop logic, but should be a small prefix instead of for ;; done
function rep() {
  [[ $# == 0 ]] && echo -e "\nUsage: rep <n> cmd # Runs cmd n times or forever if no n\n" &&  exit 1
  N=$1
  if [[ $N =~ ^[0-9]*$ ]] ; then
    shift
    for n in `seq $N` ; do $* ; done
  else 
    while true ; do $* ; done
  fi
}

function rep_til_failure() {
  true ; while [[ "$?" == "0" ]]  ; do $* ; done
}

for n in `seq 9` ; do alias $n="rep $n " ; done
alias ..='cd ..' # stupid, but I like chaining it to the rep numbers.  

#for f in "cd" ; do export $f ; done

# prints color codes for use in tmux and vim
#function colors() {
  #for i in {0..255} ; do     
    #printf "\x1b[38;5;${i}mcolour${i}\n"; 
  #done | less
#}

# xephy wrapper
function xnest() {
  if [[ $1 == '-h' ]] ; then
    echo -e "Usage: xnest [widthxheight] program\n\n"
  fi

  if [[ $1 =~ [0-9]+x[0-9] ]] ; then
    RESOLUTION=" -screen $1 "
    shift
  fi

  NTH=$(find /tmp/.X*-lock | wc -l)
  X=":$NTH.0"

  Xephyr $X $RESOLUTION &
  PID=$!

  sleep 1
  DISPLAY=$X $@
  kill $PID
}

function hl() {
  sed -e "s/$@/$(byellow $@)/g"
}

function assert_ssh_agent() {
  if [ -z "${SSH_AGENT_PID+xxx}" ] ; then
    false 
  else 
    true
  fi
}

# downscales a movie to 1000k - good for streaming over powerline to xbox
function ffmpeg_xbox() {
  #ffmpeg.git -i "$@" -vcodec mpeg4 -b:v 1000k -s hd480 "$@".avi
  ffmpeg.git -i "$@" -vcodec h264 -b:v 1000k -s 640x480 "$@".avi
}

# lists a function's definition
function func() {
  awk "/function $1\(/,/^}/" ~/.functions
}

# wrapper for ssh.  resets xterm colors after connection.  see .ssh/config's localcommands.
if [[ -x "$(which xtermcontrol)" && "$TERM" == 'xterm' ]] ; then
  _ssh=$(which ssh)

  function ssh() {
    FG=$(xtermcontrol --get-fg)
    BG=$(xtermcontrol --get-bg)
    $_ssh "$@"
    xtermcontrol --fg="$FG"
    xtermcontrol --bg="$BG"
  }
fi

# check if dmenu has an option
function dmenu_has() {
  match="\[$@ "
  [ "$(dmenu -h 2>&1 > /dev/null | grep -- $match)" != '' ]
}

function byzanz-dimensions() {
  info="$(xwininfo)"
  x=$(echo "$info" | grep 'Absolute upper-left X' | cut -f 7 -d' ')
  y=$(echo "$info" | grep 'Absolute upper-left Y' | cut -f 7 -d' ')
  w=$(echo "$info" | grep Width | cut -f 4 -d' ')
  h=$(echo "$info" | grep Height | cut -f 4 -d' ')

  echo "-x $x -w $w -y $y -h $h"
}

# color print
function black()   { echo -en "\e[0;30m$@\e[0m"; }
function red()     { echo -en "\e[0;31m$@\e[0m"; }
function green()   { echo -en "\e[0;32m$@\e[0m"; }
function yellow()  { echo -en "\e[0;33m$@\e[0m"; }
function blue()    { echo -en "\e[0;34m$@\e[0m"; }
function magenta() { echo -en "\e[0;35m$@\e[0m"; }
function cyan()    { echo -en "\e[0;36m$@\e[0m"; }
function white()   { echo -en "\e[0;97m$@\e[0m"; }

function bblack()  { echo -en "\e[1;30m$@\e[0m"; }
function bred()    { echo -en "\e[1;31m$@\e[0m"; }
function bgreen()  { echo -en "\e[1;32m$@\e[0m"; }
function byellow()  { echo -en "\e[1;33m$@\e[0m"; }
function bblue()   { echo -en "\e[1;34m$@\e[0m"; }
function bpurple()  { echo -en "\e[1;35m$@\e[0m"; }
function bcyan()  { echo -en "\e[1;36m$@\e[0m"; }
function bwhite()  { echo -en "\e[1;37m$@\e[0m"; }

# watch a file.  do something whenever it changes
function file-write-do {
  FILE=$1
  shift
  while [ $? -eq 0 ] && [ -x /usr/bin/inotifywait ] ; do
    inotifywait "$FILE" -e MODIFY &> /dev/null
    $SHELL -c $@
    sleep .1
  done
}

# pluck nth column.  defaults to first.
nth() {
  N=${1:-1}
  awk "{print \$$N}"
}
