###functions

#ls which does ls -lh on result of which.  useful if /usr/bin/$BINARY is a symlink 
function lw() { 
	 if [ $# -gt 1 ] ; then 
	    for bin in $@ ; do lw $bin ; done 
     elif [ $# -gt 0  ] ; then
       bin=$(which $1)
       [[ "$?" == "0" && -e "$bin" ]] && ls -lh "$bin"
       [[ -L "$bin" ]] && lw $(readlink $bin) || true
	 else 
	    echo "lw (ls which) requires more than 0 arguments"
	 fi  
}

#make a dir, cd into it
function mkcd() {
	 mkdir -p "$@";
	 pushd "$@" > /dev/null;
	 echo $PWD;
}

# extract archives.  should handle multiple files.
function x() {
	 case $@ in 
	     *.tar.bz2)		tar -xvjf "$@"	;;	
	     *.tar.gz)		tar -xvzf "$@"	;;
	     *.bz2)		bunzip2 "$@"	;;
	     *.rar)		unrar x "$@"	;;
	     *.gz)		gunzip "$@"	;;
	     *.tar) 		tar xf "$@"	;;
	     *.tbz2)		tar -xvjf "$@"	;;
	     *.tgz)		tar -xvzf "$@"	;;
	     *.zip)		unzip "$@"  	;;
	     *.xpi)		unzip "$@"  	;;
	     *.Z)		uncompress "$@"	;;
	     *.7z)		7z x "$@"	;;
	     *.ace)		unace e "$@"	;;
	     *.arj)		arj -y e "$@"	;;
	     *)			echo "'$@' cannot be extracted via x()"	;;
	 esac
}

# packs $2-$n into $1 depending on $1's extension.  add more file types as needed
function pack() {
	 if [ $# -lt 2 ] ; then
	    echo -e "\npack() usage:"
	    echo -e "\tpack archive_file_name file1 file2 ... fileN"
	    echo -e "\tcreates archive of files 1-N\n"
	 else 
	   DEST=$1
	   shift

	   case $DEST in 
		*.tar.bz2)		tar -cvjf $DEST "$@" ;;  
		*.tar.gz)		tar -cvzf $DEST "$@" ;;  
		*.tgz)  		tar -cvzf $DEST "$@" ;;  
		*.zip)			zip -r $DEST "$@" ;;
		*.xpi)			zip -r $DEST "$@" ;;
        *.7z)           7z a $DEST "$@" ;;
		*)				echo "Unknown file type - $DEST" ;;
	   esac
	 fi
}

# like sleep, but spits out a . every second
function delay() {
	 typeset -i NUM
	 NUM=$1
	 if [ $NUM -gt 0 ] ; then
	     for i in `seq $NUM` ; do sleep 1 ; echo -n '.' ; done
	     echo ""
	 else
	     echo "Invalid argument.  Please use a positive integer."
	 fi
}

# changes cd to pushd.  as a function so that cd with no args still brings you home.  see pd as popd
function cd() {
    if [ $# -eq 0 ] ; then
	pushd $HOME
    else
	pushd "$@" > /dev/null
    fi
}

# screen attach.  if multiple, presents a menu for choosing.
function ssx() {
    OPTS=`screen -ls | grep "[0-9]\." | while read line ; do echo "$line" | sed -e 's/\s/_/g' ; done`

    case $(echo $OPTS | wc -w) in
	0) 
	    echo -e "\nNo screen sessions open\n" 
	    ;;
	1) 
	    SESSION=$OPTS
	    echo -e "\nAttaching to only available screen"
	    ;;
	*) 
	    echo -e "\nPick a screen session"
	    select opt in $OPTS ; do
		SESSION=$opt
		break;
	    done
	    ;;
    esac

    screen -x $(echo $SESSION | sed -e 's/\..*//')

}

function calc() {
	awk "BEGIN{ print $* }" ;
}

# returns age of file in seconds
function age() {
	CURRENT=$( date +%s )
	FILEAGE=$( stat -t $1 -c %Z )
	calc $CURRENT - $FILEAGE
}

# many or multi grep.  syntactic sugar for grep -l | xargs grep
function mgrep() {
    EXEC="ls "
    for term in "$@" ; do
        EXEC="$EXEC | xargs grep -l -i '$term' "
    done
    #echo $EXEC 1>&2
    eval $EXEC
}

function roll() {
    if [ $# -lt 1 ]  ; then
        echo -e "\nUsage: roll [n] d\n\nRoll n dice of size d.  If left out, n is assumed to be one.\n"
    else
        TYPE=$1
        if [ $# -eq 2 ] ; then
            TYPE=$2
            NUM=$1
        else
            NUM=1
        fi

        SUM=0
        for i in `seq $NUM` ; do 
            # seq 1 $TYPE | shuf -n 1
            ROLL=$(( $RANDOM%$TYPE + 1 ))
            echo $ROLL
            SUM=$(( $SUM + $ROLL ))
        done
        
        echo 
        echo "=> $SUM"
    fi

}
function nosleep() {
    # if this still doesn't work, fork $@ and run deactivate or reset periodically
    xset -dpms
    xset s off
    $@
    xset +dpms
    xset s on
}

function dec2base() {
    if [ $# -ne 2 ] ; then
        echo -e "\nUsage: dec2base number base.\n"
    else 
        echo "$1 $2 o p " | dc
    fi
}

# prints n paragraphs of lorem ipsum text.  n defaults to 5 thanks to lipsum.com being cool.
function loremipsum() {
     curl -s "http://loripsum.net/api/$1/short/headers/plaintext"
}

# repeats a command n times.  no loop logic, but should be a small prefix instead of for ;; done
function rep() {
    if [ $# -lt 2 ] ; then
        echo -e "\nUsage: rep N cmd\nRuns cmd N times\n"
    else
        N=$1
        shift
        for n in `seq $N` ; do $@ ; done
    fi
}

alias 1='rep 1 '
alias 2='rep 2 '
alias 3='rep 3 '
alias 4='rep 4 '
alias 5='rep 5 '
alias 6='rep 6 '

#for f in "cd" ; do export $f ; done

# prints color codes for use in tmux and vim
#function colors() {
  #for i in {0..255} ; do     
    #printf "\x1b[38;5;${i}mcolour${i}\n"; 
  #done | less
#}

# xephy wrapper
function xnest() {
  if [[ $1 == '-h' ]] ; then
    echo -e "Usage: xnest [widthxheight] program\n\n"
  fi

  if [[ $1 =~ [0-9]+x[0-9] ]] ; then
    RESOLUTION=" -screen $1 "
    shift
  fi

  NTH=$(find /tmp/.X*-lock | wc -l)
  X=":$NTH.0"

  Xephyr $X $RESOLUTION &
  PID=$!

  sleep 1
  DISPLAY=$X $@
  kill $PID
}

# tail follow and beep
function tfb() {
  tail -F $@ | while true ; do
    if read -t 60 LINE ; then 
      echo -e "\a$LINE"
    fi
  done
}

# tail follow all args and notify-send results
function tfn() {
  tail -F $@ | while true ; do # sends same line forever.
    if read -t 60 LINE ; then 
      notify-send "$@" "$LINE"
    fi
  done
}

# claims memory.  tells firefox to back off.
function malloc() {
  if [[ $# -eq 0 || $1 -eq '-h' || $1 -lt 0 ]] ; then
    echo -e "usage: malloc N\n\nAllocate N mb, wait, then release it."
  else 
    N=$(free -m | grep Mem: | awk '{print int($2/10)}')
    if [[ $N -gt $1 ]] ;then 
      N=$1
    fi
    sh -c "MEMBLOB=\$(dd if=/dev/urandom bs=1MB count=$N) ; sleep 1"
  fi
}

function hl() {
  sed -e "s/$@/$(byellow $@)/g"
}

function assert_ssh_agent() {
  if [ -z "${SSH_AGENT_PID+xxx}" ] ; then
    false 
  else 
    true
  fi
}

# downscales a movie to 1000k - good for streaming over powerline to xbox
function ffmpeg_xbox() {
  #ffmpeg.git -i "$@" -vcodec mpeg4 -b:v 1000k -s hd480 "$@".avi
  ffmpeg.git -i "$@" -vcodec h264 -b:v 1000k -s 640x480 "$@".avi
}

# lists a function's definition
function func() {
  awk "/function $1\(/,/^}/" ~/.functions
}

# wrapper for ssh.  resets xterm colors after connection.  see .ssh/config's localcommands.
if [[ -x "$(which xtermcontrol)" && "$TERM" == 'xterm' ]] ; then
  _ssh=$(which ssh)

  function ssh() {
    FG=$(xtermcontrol --get-fg)
    BG=$(xtermcontrol --get-bg)
    $_ssh "$@"
    xtermcontrol --fg="$FG"
    xtermcontrol --bg="$BG"
  }
fi

# check if dmenu has an option
function dmenu_has() {
  match="\[$@ "
  [ "$(dmenu -h 2>&1 > /dev/null | grep -- $match)" != '' ]
}

function sls() {
  #lets try to recreate super ls with find
  if [[ "$#" == 0 || "$1" == '-h' ]] ; then
    echo 'sls - Use with man finds printf operators'
    return 1
  fi

  find ./ -maxdepth 1 -printf "$@\n"
}

# grab dimensions of a window, format for use with byzanz `byzanz-dimensions` file.gif
function byzanz-dimensions() {
  info="$(xwininfo)"
  x=$(echo "$info" | grep 'Absolute upper-left X' | cut -f 7 -d' ')
  y=$(echo "$info" | grep 'Absolute upper-left Y' | cut -f 7 -d' ')
  w=$(echo "$info" | grep Width | cut -f 4 -d' ')
  h=$(echo "$info" | grep Height | cut -f 4 -d' ')

  echo "-x $x -w $w -y $y -h $h"
}

# color print
function black()   { echo -en "\e[0;30m$@\e[0m"; }
function red()     { echo -en "\e[0;31m$@\e[0m"; }
function green()   { echo -en "\e[0;32m$@\e[0m"; }
function yellow()  { echo -en "\e[0;33m$@\e[0m"; }
function blue()    { echo -en "\e[0;34m$@\e[0m"; }
function magenta() { echo -en "\e[0;35m$@\e[0m"; }
function cyan()    { echo -en "\e[0;36m$@\e[0m"; }
function white()   { echo -en "\e[0;97m$@\e[0m"; }

function bblack()  { echo -en "\e[1;30m$@\e[0m"; }
function bred()    { echo -en "\e[1;31m$@\e[0m"; }
function bgreen()  { echo -en "\e[1;32m$@\e[0m"; }
function byellow()  { echo -en "\e[1;33m$@\e[0m"; }
function bblue()   { echo -en "\e[1;34m$@\e[0m"; }
function bpurple()  { echo -en "\e[1;35m$@\e[0m"; }
function bcyan()  { echo -en "\e[1;36m$@\e[0m"; }
function bwhite()  { echo -en "\e[1;37m$@\e[0m"; }
